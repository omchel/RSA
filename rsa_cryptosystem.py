# -*- coding: utf-8 -*-
"""RSA Cryptosystem

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1D8GBz1y6QJk4YmKM-UfgYyXF4NrpSeGa

## RSA Implementation

**Author**: Chelina Ortiz Montanez

**Class**: CS378 - Intro to Cryptology

**Prompt**: The objective of this project is to implement components of the RSA cryptosystem.

**References**: Introduction to Cryptography with Coding by Washington, Lawrence and Trap; notes provided in class.
"""

from random import randrange, randint, getrandbits

"""**Key Setup**

This module will compute and output the keys: public and private. The keys will be output to two separate files named public key and private key. 

The function **setupKeys** creates the public and private keys for RSA by:

1.   Set up the exponent e = 2^16 + 1 (generally good e value)
2.   Generate random prime values of p and q 
3.   Use the EEA function to get the gcd of e and phi(n) [phi(n) = (p-1)*(q-1)]
4.   Verify that p and q have a difference of at least 10^95 and that the gcd (e, phi(n)) = 1, if not, generate new p and q and find new gcd
5.   When the conditions are met, the value of d is going to be the value of x that we got from EEA (because a^-1 = x mod n)
6.   Calculate n = p*q
7.   Export n, e to public key file and d to private key file.


---



*Helper Functions*

The function **modExp** returns y^x (mod n), calculates the modular exponentiation using algorithm found on Exercise 23 a) from the Introduction to Cryptography book, page 107-108

The function **isPrime** returns true if the number input is prime using the Miller-Rabin primality test found on the class notes, page 67 (notes-zoom)

The function **randPrime** returns a random number (100 digits/512 bits long) that was tested for primality using the isPrime function.

The function **EEA** returns the values x, y, and the gcd such that ax + by = gcd(a, b) using the formula found on section 3.2 'Solving ax + by = d' from the Introduction to Cryptology book, page 69
"""

## modExp Function:
##  returns y^x (mod n)
def modExp(y, x, n):
  d = bin(x)[2:] # Convert the exponent into binary string
  w = len(d) # Number of characters in the binary string (indexed from zero)
  s = 1 # Carry variable for the result
  r = 0 # Result
  k = 0 # iterator

  # When k = w, r_w = y^x (mod n)
  while k < w:
    # if the binary character is 1 in this index, multiply s by y (mod n)
    if d[k] == '1':
      r = (s * y) % n
    elif d[k] == '0':
      r = s
    # s = r^2 (mod 2)
    s = (r * r) % n
    k += 1 # add 1 to the iterator
  return int(r)

## isPrime Function:
##  returns True if n is prime (according to Miller-Rabin primality test)
def isPrime(n):
  if n % 2 == 0: return False # even numbers are not prime

  ## Miller Rabbin primality test:
  a = randint(1, n); # a such that 1 < a < n
  # find k and m such that n-1 = m*2^k (m = (n-1)/2^k)
  x = n - 1
  k = 0 # increase k every iteration
  while x % 2 == 0: # while the random number minus 1 is even
    x = x // 2 # divide x by 2
    k = k + 1 # increase k until x is odd
  m = (n - 1) // (2 ** k) # calculate m so it is odd 

  b = modExp(a, m, n) # calculate multiplicative inverse with m as exponent
  if b == -1 % n or b == 1 % n: 
    return True # n is prime
  for i in range(1, k): 
    b = (b * b) % n
    if b == -1 % n:
      return False # n is composite
    if b == 1 % n:
      return True # n is prime
  return False

## randPrime function:
##  returns a random, verified prime number of 100 digits/512 bits of length
def randPrime():
  randNum = getrandbits(512)
  while isPrime(randNum) == False:
    randNum = getrandbits(512) # generate a new number until it is a prime one
  return randNum

## EEA function:
##  returns x, y and the gcd of a and b such that ax+by = gcd(a,b) (a < b)
def EEA(a, b):
  if a == 0: return 0, 1, b
  
  x_0, y_0, gcd = EEA(b % a, a) # recursively calculate x_0, y_0 and gcd value
  q = b // a # quotient value
  x = -q * x_0 + y_0 # formula: x_j = -q_(j-1)*x_(j-1) + x_(j-1) 
  y = x_0 # y_j = x_(j-1) (y is always equal to the previous x value, as above)
  return x, y, gcd

## setupKeys function:
##  generate adecuate public and private keys for a working RSA system
def setupKeys():
  e = 2 ** 16 + 1 # should be 65537, using the same e for any n in this system

  # Generate random prime values of p and q
  p = randPrime()
  q = randPrime()
  phi = (p - 1) * (q - 1) # phi(n) = (p-1)*(q-1)

  # Use the EEA function to get the gcd of e and phi(n) 
  x, y, gcd = EEA(e, phi)

  # Verify that p and q have a difference of at least 10^95 and that the 
  #   gcd(e, phi(n)) = 1, if not, generate new p and q and find new gcd
  while (p-q) < (10**95) or gcd != 1:
    p = randPrime()
    q = randPrime()
    phi = (p - 1) * (q - 1)
    x, y, gcd = EEA(e, phi)

  d = x # x is the multiplicative inverse of e^-1 mod phi
  n = p * q

  # export generated keys
  with open('public_key.txt', 'w+') as file:
    file.writelines([str(n), "\n", str(e)])
    file.close()
  with open('private_key.txt', 'w+') as file:
    file.write(str(d))
    file.close()

  print('Key setup: complete')
  return

"""**Encryption** 

This module will take the public key and a message to be encrypted as the inputs. They
will be read from the files public key and message, respectively. The module will output the ciphertext
(encrypted message) which will be stored in a file named ciphertext.
"""

## RSAencryption function:
##   using public keys and a message file, compute c = m^e mod n, store c in a
##   text file
def RSAencryption():
  with open('public_key.txt') as file:
    n = file.readline()
    e = file.readline()
    file.close()

  with open('message.txt') as file:
    m = file.readline()
    file.close()

  c = modExp(int(m), int(e), int(n))

  with open('ciphertext.txt', 'w') as file:
    file.write(str(c))
    file.close

  print('Encryption using RSA: complete. Please check the file ciphertext.')
  return

"""**Decryption**

This module will take the public key, the private key and the ciphertext to be decrypted as the
inputs. They will be read from the files public key, private key and ciphertext, respectively. The module
will output the decrypted message and store it in a file named decrypted message.
"""

## RSAdecryption function:
##   using public key n, the private key and a ciphertext file, compute 
##   m = c^d mod n, store decrypted nessage m in a text file
def RSAdecryption():
  with open('public_key.txt') as file:
    n = file.readline()
    file.close()

  with open('private_key.txt') as file:
    d = file.readline()
    file.close()

  with open('ciphertext.txt') as file:
    c = file.readline()
    file.close()

  m = modExp(int(c), int(d), int(n))

  with open('decrypted_text.txt', 'w') as file:
    file.write(str(m))
    file.close

  print('Decryption using RSA: complete. Please check the file decrypted message.')
  return

setupKeys()
RSAencryption()
RSAdecryption()